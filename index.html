<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF-Beschriftungssystem</title>
    <!-- Yerel PDF.js kütüphanesi -->
    <script src="lib/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
        }
        .main-content {
            display: flex;
            min-height: 600px;
        }
        .sidebar {
            width: 300px;
            padding: 20px;
            background: #f8f9fa;
            border-right: 1px solid #ddd;
        }
        .workspace {
            flex: 1;
            padding: 20px;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        .btn-primary {
            background: #667eea;
            color: white;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .input-group input[type="text"] {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .input-group input[type="color"] {
            width: 40px;
            height: 36px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .label-list, .pdf-list {
            margin-top: 10px;
        }
        .label-item, .pdf-item {
            padding: 10px;
            border: 1px solid #ddd;
            margin-bottom: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .label-item.active, .pdf-item.active {
            background: #e6f0ff;
        }
        .label-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #ddd;
        }
        #pdfDisplay {
            border: 2px dashed #ddd;
            padding: 20px;
            min-height: 400px;
            margin-top: 20px;
        }
        #pdfCanvas {
            max-width: 100%;
        }
        .text-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.2;
            z-index: 10;
        }
        .text-layer > span {
            color: transparent;
            position: absolute;
            cursor: pointer;
            border-radius: 3px;
        }
        .text-layer > span:hover {
            background: rgba(102, 126, 234, 0.3);
            opacity: 1;
        }
        .annotation-highlight {
            position: absolute;
            background: rgba(102, 126, 234, 0.3);
            border: 2px solid;
            pointer-events: none;
            z-index: 5;
        }
        .group-badge {
            position: absolute;
            background: white;
            border: 2px solid;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            z-index: 15;
            pointer-events: none;
            top: -5px;
            right: -5px;
        }
        .mode-toggle {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .mode-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
        }
        .mode-btn.active {
            background: #667eea;
            color: white;
        }
        #statusText {
            margin-top: 10px;
            color: #333;
        }
        .context-menu {
            position: fixed;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            padding: 5px 0;
            min-width: 200px;
        }
        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .context-menu-item:hover {
            background: #f0f3ff;
        }
        .context-menu-divider {
            height: 1px;
            background: #ddd;
            margin: 5px 0;
        }
        .group-input-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            z-index: 1001;
            padding: 20px;
            min-width: 300px;
        }
        .group-input-dialog h3 {
            margin-bottom: 15px;
            color: #667eea;
        }
        .group-input-dialog input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .group-input-dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        .footer {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PDF-Beschriftungssystem</h1>
        <div class="main-content">
            <div class="sidebar">
                <div>
                    <h3>Projekt</h3>
                    <button class="btn btn-primary" id="newProjectBtn">Neues Projekt erstellen</button>
                    <button class="btn btn-success" id="saveProjectBtn" disabled>Projekt speichern</button>
                    <button class="btn btn-primary" id="loadProjectBtn">Projekt laden</button>
                    <input type="file" id="projectFileInput" accept=".json" style="display: none;">
                </div>
                <div>
                    <h3>Beschriftungen</h3>
                    <div class="input-group">
                        <input type="text" id="labelInput" placeholder="Beschriftungsname" disabled>
                        <input type="color" id="colorInput" value="#ff6b6b" disabled>
                        <button class="btn btn-success" id="addLabelBtn" disabled>Hinzufügen</button>
                    </div>
                    <div class="label-list" id="labelList"></div>
                </div>
                <div>
                    <h3>Modus</h3>
                    <div class="mode-toggle">
                        <button class="mode-btn active" id="labelModeBtn">Beschriftung</button>
                        <button class="mode-btn" id="eraserModeBtn">Radierer</button>
                    </div>
                </div>
                <div>
                    <h3>PDF-Datei</h3>
                    <input type="file" id="pdfFileInput" accept=".pdf" style="display: none;" disabled>
                    <button class="btn btn-primary" id="uploadPdfBtn" disabled>PDF hochladen</button>
                    <div class="pdf-list" id="pdfList"></div>
                </div>
            </div>
            <div class="workspace">
                <div>
                    <h3>PDF-Anzeige</h3>
                    <div id="pdfDisplay">PDF wird erwartet...</div>
                </div>
                <div>
                    <h3>Exportieren</h3>
                    <button class="btn btn-success" id="exportJsonBtn" disabled>JSON herunterladen</button>
                    <button class="btn btn-success" id="exportCsvBtn" disabled>CSV herunterladen</button>
                </div>
            </div>
        </div>
        <div id="statusText">Status: Bereit</div>
        <div class="footer">Entwickelt von Fatih Dayan</div>
    </div>

    <script>
        // PDF.js yüklenmesini kontrol et
        if (typeof pdfjsLib === 'undefined') {
            console.error('PDF.js-Bibliothek konnte nicht geladen werden. Überprüfen Sie die Datei lib/pdf.min.js.');
            document.getElementById('statusText').textContent = 'Fehler: PDF.js-Bibliothek konnte nicht geladen werden';
            alert('PDF.js-Bibliothek konnte nicht geladen werden. Überprüfen Sie die Datei lib/pdf.min.js.');
        } else {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'lib/pdf.worker.min.js';
        }

        let projectData = {
            name: '',
            date: '',
            classes: {},
            files: {},
            activeLabel: null,
            isEraser: false
        };
        let currentPdfFile = null;
        let currentPdfDoc = null;
        let currentPage = 1;
        let textSpanMap = new Map();

        // DOM Elements
        const elements = {
            newProjectBtn: document.getElementById('newProjectBtn'),
            saveProjectBtn: document.getElementById('saveProjectBtn'),
            loadProjectBtn: document.getElementById('loadProjectBtn'),
            projectFileInput: document.getElementById('projectFileInput'),
            labelInput: document.getElementById('labelInput'),
            colorInput: document.getElementById('colorInput'),
            addLabelBtn: document.getElementById('addLabelBtn'),
            labelList: document.getElementById('labelList'),
            uploadPdfBtn: document.getElementById('uploadPdfBtn'),
            pdfFileInput: document.getElementById('pdfFileInput'),
            pdfList: document.getElementById('pdfList'),
            pdfDisplay: document.getElementById('pdfDisplay'),
            labelModeBtn: document.getElementById('labelModeBtn'),
            eraserModeBtn: document.getElementById('eraserModeBtn'),
            exportJsonBtn: document.getElementById('exportJsonBtn'),
            exportCsvBtn: document.getElementById('exportCsvBtn'),
            statusText: document.getElementById('statusText'),
        };

        // Event Listeners
        elements.newProjectBtn.addEventListener('click', () => {
            console.log('Neues Projekt erstellen geklickt');
            createNewProject();
        });
        elements.saveProjectBtn.addEventListener('click', () => {
            console.log('Projekt speichern geklickt');
            saveProject();
        });
        elements.loadProjectBtn.addEventListener('click', () => {
            console.log('Projekt laden geklickt');
            elements.projectFileInput.click();
        });
        elements.addLabelBtn.addEventListener('click', () => {
            console.log('Beschriftung hinzufügen geklickt');
            addLabel();
        });
        elements.uploadPdfBtn.addEventListener('click', () => {
            console.log('PDF hochladen geklickt');
            elements.pdfFileInput.click();
        });
        elements.labelModeBtn.addEventListener('click', () => {
            console.log('Beschriftungsmodus ausgewählt');
            projectData.isEraser = false;
            elements.labelModeBtn.classList.add('active');
            elements.eraserModeBtn.classList.remove('active');
            updateStatus(`Aktiver Modus: Beschriftung (${projectData.activeLabel || 'Nicht ausgewählt'})`);
        });
        elements.eraserModeBtn.addEventListener('click', () => {
            console.log('Radierermodus ausgewählt');
            projectData.isEraser = true;
            projectData.activeLabel = null;
            elements.eraserModeBtn.classList.add('active');
            elements.labelModeBtn.classList.remove('active');
            updateStatus('Aktiver Modus: Radierer');
        });
        elements.exportJsonBtn.addEventListener('click', () => {
            console.log('JSON herunterladen geklickt');
            exportJson();
        });
        elements.exportCsvBtn.addEventListener('click', () => {
            console.log('CSV herunterladen geklickt');
            exportCsv();
        });
        elements.projectFileInput.addEventListener('change', loadProject);
        elements.pdfFileInput.addEventListener('change', uploadPdf);

        // Close context menu on click
        document.addEventListener('click', () => {
            const menus = document.querySelectorAll('.context-menu');
            menus.forEach(m => m.remove());
        });

        function createNewProject() {
            try {
                const projectName = prompt('Projektname eingeben:');
                if (projectName) {
                    projectData = {
                        name: projectName,
                        date: new Date().toLocaleDateString('de-DE'),
                        classes: {},
                        files: {},
                        activeLabel: null,
                        isEraser: false
                    };
                    currentPdfFile = null;
                    currentPdfDoc = null;
                    elements.saveProjectBtn.disabled = false;
                    elements.labelInput.disabled = false;
                    elements.colorInput.disabled = false;
                    elements.addLabelBtn.disabled = false;
                    elements.uploadPdfBtn.disabled = true;
                    elements.pdfFileInput.disabled = true;
                    elements.exportJsonBtn.disabled = true;
                    elements.exportCsvBtn.disabled = true;
                    elements.pdfDisplay.innerHTML = 'PDF wird erwartet...';
                    elements.pdfList.innerHTML = '';
                    elements.labelList.innerHTML = '';
                    updateStatus(`Neues Projekt "${projectName}" erstellt`);
                }
            } catch (err) {
                console.error('Fehler beim Erstellen eines neuen Projekts:', err);
                updateStatus('Fehler: Neues Projekt konnte nicht erstellt werden');
            }
        }

        function saveProject() {
            try {
                const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${projectData.name || 'projekt'}_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                updateStatus('Projekt gespeichert');
            } catch (err) {
                console.error('Fehler beim Speichern des Projekts:', err);
                updateStatus('Fehler: Projekt konnte nicht gespeichert werden');
            }
        }

        function loadProject(e) {
            try {
                const file = e.target.files[0];
                if (!file) {
                    updateStatus('Fehler: Keine Datei ausgewählt');
                    return;
                }
                console.log('Projektdatei ausgewählt:', file.name);
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const loadedData = JSON.parse(event.target.result);
                        if (!loadedData.name || !loadedData.date || !loadedData.files || !loadedData.classes) {
                            throw new Error('Ungültiges Projektdateiformat');
                        }
                        projectData = {
                            name: loadedData.name,
                            date: loadedData.date,
                            classes: loadedData.classes || {},
                            files: loadedData.files || {},
                            activeLabel: null,
                            isEraser: false
                        };
                        currentPdfFile = null;
                        currentPdfDoc = null;
                        elements.saveProjectBtn.disabled = false;
                        elements.labelInput.disabled = false;
                        elements.colorInput.disabled = false;
                        elements.addLabelBtn.disabled = false;
                        elements.uploadPdfBtn.disabled = false;
                        elements.pdfFileInput.disabled = false;
                        elements.exportJsonBtn.disabled = false;
                        elements.exportCsvBtn.disabled = false;
                        elements.pdfDisplay.innerHTML = 'PDF wird erwartet...';
                        renderLabels();
                        renderPdfList();
                        updateStatus(`Projekt "${projectData.name}" geladen`);
                    } catch (err) {
                        console.error('Fehler beim Verarbeiten der Projektdatei:', err);
                        updateStatus('Fehler: Projektdatei konnte nicht geladen werden');
                        alert('Projektdatei konnte nicht geladen werden: ' + err.message);
                    }
                };
                reader.onerror = (err) => {
                    console.error('Fehler beim Lesen der Projektdatei:', err);
                    updateStatus('Fehler: Projektdatei konnte nicht gelesen werden');
                };
                reader.readAsText(file);
                e.target.value = '';
            } catch (err) {
                console.error('Fehler beim Laden des Projekts:', err);
                updateStatus('Fehler: Projekt konnte nicht geladen werden');
            }
        }

        function addLabel() {
            try {
                const labelName = elements.labelInput.value.trim();
                const labelColor = elements.colorInput.value;
                if (labelName && !projectData.classes[labelName]) {
                    projectData.classes[labelName] = labelColor;
                    renderLabels();
                    elements.labelInput.value = '';
                    elements.uploadPdfBtn.disabled = false;
                    elements.pdfFileInput.disabled = false;
                    elements.exportJsonBtn.disabled = false;
                    elements.exportCsvBtn.disabled = false;
                    updateStatus(`Beschriftung "${labelName}" hinzugefügt`);
                } else {
                    updateStatus('Fehler: Beschriftungsname leer oder bereits vorhanden');
                }
            } catch (err) {
                console.error('Fehler beim Hinzufügen der Beschriftung:', err);
                updateStatus('Fehler: Beschriftung konnte nicht hinzugefügt werden');
            }
        }

        function renderLabels() {
            elements.labelList.innerHTML = '';
            Object.entries(projectData.classes).forEach(([name, color]) => {
                const item = document.createElement('div');
                item.className = `label-item ${projectData.activeLabel === name ? 'active' : ''}`;
                item.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div class="label-color" style="background: ${color};"></div>
                        <span>${name}</span>
                    </div>
                    <button class="btn btn-danger" onclick="deleteLabel('${name}')">Löschen</button>
                `;
                item.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('btn')) {
                        projectData.activeLabel = name;
                        projectData.isEraser = false;
                        elements.labelModeBtn.classList.add('active');
                        elements.eraserModeBtn.classList.remove('active');
                        renderLabels();
                        updateStatus(`Aktive Beschriftung: ${name}`);
                    }
                });
                elements.labelList.appendChild(item);
            });
        }

        window.deleteLabel = function(name) {
            try {
                if (confirm(`Möchten Sie die Beschriftung "${name}" wirklich löschen?`)) {
                    delete projectData.classes[name];
                    if (projectData.activeLabel === name) {
                        projectData.activeLabel = null;
                    }
                    renderLabels();
                    updateStatus(`Beschriftung "${name}" gelöscht`);
                }
            } catch (err) {
                console.error('Fehler beim Löschen der Beschriftung:', err);
                updateStatus('Fehler: Beschriftung konnte nicht gelöscht werden');
            }
        };

        async function uploadPdf(e) {
            if (typeof pdfjsLib === 'undefined') {
                updateStatus('Fehler: PDF.js-Bibliothek nicht geladen');
                return;
            }
            try {
                const file = e.target.files[0];
                if (!file) {
                    updateStatus('Fehler: Keine Datei ausgewählt');
                    return;
                }
                
                const fileName = file.name;
                projectData.files[fileName] = { 
                    annotations: {}, 
                    pdfData: null,
                    numPages: 0
                };
                Object.keys(projectData.classes).forEach(label => {
                    projectData.files[fileName].annotations[label] = [];
                });
                
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        projectData.files[fileName].pdfData = event.target.result;
                        const loadingTask = pdfjsLib.getDocument({ data: event.target.result, disableCache: true });
                        const pdf = await loadingTask.promise;
                        projectData.files[fileName].numPages = pdf.numPages;
                        renderPdfList();
                        updateStatus(`PDF "${fileName}" hochgeladen`);
                        await loadPdf(fileName);
                    } catch (err) {
                        console.error(`Fehler beim Hochladen des PDFs (${fileName}):`, err);
                        updateStatus(`Fehler: "${fileName}" konnte nicht hochgeladen werden`);
                    }
                };
                reader.onerror = (err) => {
                    console.error(`Fehler beim Lesen der Datei (${fileName}):`, err);
                    updateStatus(`Fehler: "${fileName}" konnte nicht gelesen werden`);
                };
                reader.readAsArrayBuffer(file);
                e.target.value = '';
            } catch (err) {
                console.error('Fehler beim Hochladen des PDFs:', err);
                updateStatus('Fehler: PDF konnte nicht hochgeladen werden');
            }
        }

        function renderPdfList() {
            elements.pdfList.innerHTML = '';
            Object.keys(projectData.files).forEach(fileName => {
                const item = document.createElement('div');
                item.className = `pdf-item ${currentPdfFile === fileName ? 'active' : ''}`;
                item.innerHTML = `
                    <span style="flex: 1;">${fileName}</span>
                    <button class="btn btn-danger" onclick="deletePdf('${fileName}')">Löschen</button>
                `;
                item.querySelector('span').addEventListener('click', async () => {
                    console.log('PDF ausgewählt:', fileName);
                    await loadPdf(fileName);
                });
                elements.pdfList.appendChild(item);
            });
        }

        window.deletePdf = function(fileName) {
            try {
                if (confirm(`Möchten Sie die Datei "${fileName}" wirklich löschen?`)) {
                    delete projectData.files[fileName];
                    if (currentPdfFile === fileName) {
                        currentPdfFile = null;
                        currentPdfDoc = null;
                        elements.pdfDisplay.innerHTML = 'PDF wird erwartet...';
                    }
                    renderPdfList();
                    updateStatus('PDF gelöscht');
                }
            } catch (err) {
                console.error('Fehler beim Löschen des PDFs:', err);
                updateStatus('Fehler: PDF konnte nicht gelöscht werden');
            }
        };

        async function loadPdf(fileName) {
            if (typeof pdfjsLib === 'undefined') {
                updateStatus('Fehler: PDF.js-Bibliothek nicht geladen');
                return;
            }
            if (!projectData.files[fileName] || !projectData.files[fileName].pdfData) {
                updateStatus(`Fehler: Datei "${fileName}" nicht gefunden`);
                return;
            }
            try {
                if (currentPdfDoc) {
                    await currentPdfDoc.destroy();
                    currentPdfDoc = null;
                }
                currentPdfFile = fileName;
                currentPage = 1;
                renderPdfList();
                updateStatus(`PDF "${fileName}" wird geladen...`);
                await renderPage(1);
                updateStatus(`PDF "${fileName}" geladen`);
            } catch (err) {
                console.error(`Fehler beim Laden des PDFs (${fileName}):`, err);
                updateStatus(`Fehler: "${fileName}" konnte nicht geladen werden`);
            }
        }

        async function renderPage(pageNum) {
            if (!currentPdfFile) {
                updateStatus('Fehler: Kein PDF ausgewählt');
                return;
            }
            try {
                if (!currentPdfDoc) {
                    const loadingTask = pdfjsLib.getDocument({ data: projectData.files[currentPdfFile].pdfData, disableCache: true });
                    currentPdfDoc = await loadingTask.promise;
                }
                
                currentPage = pageNum;
                const page = await currentPdfDoc.getPage(pageNum);
                const scale = 1.5;
                const viewport = page.getViewport({ scale });

                elements.pdfDisplay.innerHTML = '';
                
                // Seite kontrollieren
                const controls = document.createElement('div');
                controls.style.cssText = 'display: flex; gap: 10px; margin-bottom: 15px; align-items: center; justify-content: center;';
                controls.innerHTML = `
                    <button class="btn btn-primary" id="prevPageBtn" ${pageNum <= 1 ? 'disabled' : ''}>◀ Vorherige</button>
                    <span style="font-weight: bold; min-width: 120px; text-align: center;">Seite ${pageNum} / ${currentPdfDoc.numPages}</span>
                    <button class="btn btn-primary" id="nextPageBtn" ${pageNum >= currentPdfDoc.numPages ? 'disabled' : ''}>Nächste ▶</button>
                `;
                elements.pdfDisplay.appendChild(controls);
                
                const container = document.createElement('div');
                container.style.position = 'relative';
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const context = canvas.getContext('2d');
                await page.render({ canvasContext: context, viewport }).promise;
                container.appendChild(canvas);

                const textLayer = document.createElement('div');
                textLayer.className = 'text-layer';
                textLayer.style.width = viewport.width + 'px';
                textLayer.style.height = viewport.height + 'px';
                container.appendChild(textLayer);
                elements.pdfDisplay.appendChild(container);

                const textContent = await page.getTextContent();
                pdfjsLib.renderTextLayer({
                    textContent,
                    container: textLayer,
                    viewport,
                    textDivs: []
                }).promise.then(() => {
                    setupTextInteractivity(textLayer, pageNum);
                    restoreAnnotations(container, pageNum);
                }).catch(err => {
                    console.error('Fehler beim Laden der Textschicht:', err);
                    updateStatus('Warnung: PDF enthält keinen Text');
                });
                
                // Seite wechseln
                document.getElementById('prevPageBtn').addEventListener('click', () => {
                    if (currentPage > 1) {
                        renderPage(currentPage - 1);
                    }
                });
                
                document.getElementById('nextPageBtn').addEventListener('click', () => {
                    if (currentPage < currentPdfDoc.numPages) {
                        renderPage(currentPage + 1);
                    }
                });
                
                updateStatus(`Seite ${pageNum}/${currentPdfDoc.numPages} wird angezeigt`);
            } catch (err) {
                console.error('Fehler beim Anzeigen der Seite:', err);
                updateStatus('Fehler: PDF-Seite konnte nicht angezeigt werden');
            }
        }

        function setupTextInteractivity(textLayer, pageNum) {
            const spans = textLayer.querySelectorAll('span');
            spans.forEach((span, index) => {
                const text = span.textContent.trim();
                if (!text) return;
                const spanId = `span_${pageNum}_${index}`;
                span.dataset.id = spanId;
                textSpanMap.set(spanId, { text, page: pageNum });

                // Linksklick
                span.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (projectData.isEraser) {
                        removeAnnotationById(spanId, pageNum);
                    } else if (projectData.activeLabel) {
                        addAnnotationById(spanId, pageNum, 1);
                    } else {
                        updateStatus('Fehler: Keine Beschriftung ausgewählt');
                    }
                    restoreAnnotations(textLayer.parentElement, pageNum);
                });

                // Rechtsklick - Gruppenmenü
                span.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const annotation = findAnnotationBySpanId(spanId);
                    if (annotation) {
                        showContextMenu(e.clientX, e.clientY, spanId, pageNum, annotation);
                    }
                });

                span.addEventListener('mouseenter', () => {
                    if (!projectData.isEraser && projectData.activeLabel) {
                        span.style.background = projectData.classes[projectData.activeLabel] + '40';
                    }
                });
                span.addEventListener('mouseleave', () => {
                    span.style.background = '';
                });
            });
        }

        function addAnnotationById(spanId, pageNum, group) {
            try {
                // Zuerst alle Beschriftungen für diesen Span entfernen
                Object.keys(projectData.classes).forEach(label => {
                    const annotations = projectData.files[currentPdfFile].annotations[label] || [];
                    projectData.files[currentPdfFile].annotations[label] = annotations.filter(
                        ann => ann.spanId !== spanId
                    );
                });
                
                // Zur neuen Beschriftung hinzufügen
                if (!projectData.files[currentPdfFile].annotations[projectData.activeLabel]) {
                    projectData.files[currentPdfFile].annotations[projectData.activeLabel] = [];
                }
                projectData.files[currentPdfFile].annotations[projectData.activeLabel].push({
                    spanId: spanId,
                    page: pageNum,
                    group: group || 1
                });
            } catch (err) {
                console.error('Fehler beim Beschriftung:', err);
                updateStatus('Fehler: Beschriftung konnte nicht hinzugefügt werden');
            }
        }

        function removeAnnotationById(spanId, pageNum) {
            try {
                Object.keys(projectData.classes).forEach(label => {
                    const annotations = projectData.files[currentPdfFile].annotations[label] || [];
                    projectData.files[currentPdfFile].annotations[label] = annotations.filter(
                        ann => ann.spanId !== spanId
                    );
                });
            } catch (err) {
                console.error('Fehler beim Entfernen der Beschriftung:', err);
                updateStatus('Fehler: Beschriftung konnte nicht entfernt werden');
            }
        }

        function findAnnotationBySpanId(spanId) {
            for (const [label, annotations] of Object.entries(projectData.files[currentPdfFile].annotations)) {
                const found = annotations.find(ann => ann.spanId === spanId);
                if (found) return { ...found, label };
            }
            return null;
        }

        function showContextMenu(x, y, spanId, pageNum, annotation) {
            // Altes Menü entfernen
            const existingMenu = document.querySelector('.context-menu');
            if (existingMenu) existingMenu.remove();

            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.innerHTML = `
                <div class="context-menu-item" data-action="change-group">
                    Gruppe ändern (Aktuell: ${annotation.group || 1})
                </div>
                <div class="context-menu-divider"></div>
                <div class="context-menu-item" data-action="remove">
                    Beschriftung entfernen
                </div>
            `;

            menu.addEventListener('click', (e) => {
                const action = e.target.dataset.action;
                if (action === 'change-group') {
                    showGroupDialog(spanId, pageNum, annotation);
                } else if (action === 'remove') {
                    removeAnnotationById(spanId, pageNum);
                    restoreAnnotations(document.querySelector('#pdfDisplay > div'), pageNum);
                }
                menu.remove();
            });

            document.body.appendChild(menu);
        }

        function showGroupDialog(spanId, pageNum, annotation) {
            const overlay = document.createElement('div');
            overlay.className = 'overlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'group-input-dialog';
            dialog.innerHTML = `
                <h3>Gruppennummer zuweisen</h3>
                <input type="number" id="groupInput" min="1" value="${annotation.group || 1}" placeholder="Gruppennummer (1, 2, 3...)">
                <div class="group-input-dialog-buttons">
                    <button class="btn btn-primary" id="groupOkBtn">OK</button>
                    <button class="btn btn-danger" id="groupCancelBtn">Abbrechen</button>
                </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);

            const input = document.getElementById('groupInput');
            input.focus();
            input.select();

            document.getElementById('groupOkBtn').addEventListener('click', () => {
                const groupNum = parseInt(input.value) || 1;
                changeAnnotationGroup(spanId, pageNum, annotation.label, groupNum);
                overlay.remove();
                dialog.remove();
                restoreAnnotations(document.querySelector('#pdfDisplay > div'), pageNum);
            });

            document.getElementById('groupCancelBtn').addEventListener('click', () => {
                overlay.remove();
                dialog.remove();
            });

            overlay.addEventListener('click', () => {
                overlay.remove();
                dialog.remove();
            });
        }

        function changeAnnotationGroup(spanId, pageNum, label, newGroup) {
            try {
                const annotations = projectData.files[currentPdfFile].annotations[label];
                const ann = annotations.find(a => a.spanId === spanId);
                if (ann) {
                    ann.group = newGroup;
                    updateStatus(`Gruppe auf ${newGroup} geändert`);
                }
            } catch (err) {
                console.error('Fehler beim Ändern der Gruppe:', err);
                updateStatus('Fehler: Gruppe konnte nicht geändert werden');
            }
        }

        function restoreAnnotations(container, pageNum) {
            // Alte Highlights und Badges entfernen
            const existingHighlights = container.querySelectorAll('.annotation-highlight');
            const existingBadges = container.querySelectorAll('.group-badge');
            existingHighlights.forEach(h => h.remove());
            existingBadges.forEach(b => b.remove());

            Object.entries(projectData.classes).forEach(([label, color]) => {
                const annotations = projectData.files[currentPdfFile]?.annotations[label] || [];
                annotations.forEach(ann => {
                    if (ann.page === pageNum) {
                        const textLayer = container.querySelector('.text-layer');
                        const span = textLayer.querySelector(`[data-id="${ann.spanId}"]`);
                        if (!span) return;

                        const spanRect = span.getBoundingClientRect();
                        const containerRect = container.getBoundingClientRect();

                        const highlight = document.createElement('div');
                        highlight.className = 'annotation-highlight';
                        highlight.style.backgroundColor = color;
                        highlight.style.opacity = '0.3';
                        highlight.style.left = `${spanRect.left - containerRect.left}px`;
                        highlight.style.top = `${spanRect.top - containerRect.top}px`;
                        highlight.style.width = `${spanRect.width}px`;
                        highlight.style.height = `${spanRect.height}px`;
                        highlight.style.borderColor = color;
                        container.appendChild(highlight);

                        // Gruppenbadge hinzufügen (für Gruppe 2 und höher)
                        if (ann.group && ann.group > 1) {
                            const badge = document.createElement('div');
                            badge.className = 'group-badge';
                            badge.textContent = ann.group;
                            badge.style.borderColor = color;
                            badge.style.color = color;
                            badge.style.left = `${spanRect.right - containerRect.left - 10}px`;
                            badge.style.top = `${spanRect.top - containerRect.top - 5}px`;
                            container.appendChild(badge);
                        }
                    }
                });
            });
        }

        function exportJson() {
            try {
                const exportData = {
                    project_name: projectData.name,
                    date: projectData.date,
                    classes: projectData.classes,
                    files: {}
                };
                
                Object.entries(projectData.files).forEach(([fileName, data]) => {
                    exportData.files[fileName] = {};
                    Object.entries(projectData.classes).forEach(([label]) => {
                        const annotations = data.annotations[label] || [];
                        
                        // In Gruppen aufteilen
                        const groups = {};
                        annotations.forEach(ann => {
                            const groupNum = ann.group || 1;
                            if (!groups[groupNum]) {
                                groups[groupNum] = [];
                            }
                            const spanInfo = textSpanMap.get(ann.spanId);
                            if (spanInfo) {
                                groups[groupNum].push(spanInfo.text);
                            }
                        });
                        
                        // Jede Gruppe als separater Schlüssel hinzufügen
                        Object.entries(groups).forEach(([groupNum, texts]) => {
                            const key = groupNum > 1 ? `${label}_Gruppe${groupNum}` : label;
                            exportData.files[fileName][key] = texts;
                        });
                    });
                });
                
                // PDF-Name ohne Erweiterung
                const pdfName = currentPdfFile ? currentPdfFile.replace('.pdf', '') : projectData.name || 'export';
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${pdfName}.json`;
                a.click();
                URL.revokeObjectURL(url);
                updateStatus('Als JSON exportiert');
            } catch (err) {
                console.error('Fehler beim JSON-Export:', err);
                updateStatus('Fehler: JSON konnte nicht exportiert werden');
            }
        }

        function exportCsv() {
            try {
                let csv = 'PDF-Datei,Beschriftung,Wert\n';
                
                Object.entries(projectData.files).forEach(([fileName, data]) => {
                    Object.entries(projectData.classes).forEach(([label]) => {
                        const annotations = data.annotations[label] || [];
                        
                        // In Gruppen aufteilen
                        const groups = {};
                        annotations.forEach(ann => {
                            const groupNum = ann.group || 1;
                            if (!groups[groupNum]) {
                                groups[groupNum] = [];
                            }
                            const spanInfo = textSpanMap.get(ann.spanId);
                            if (spanInfo) {
                                groups[groupNum].push(spanInfo.text);
                            }
                        });
                        
                        // Jede Gruppe als separate Zeile hinzufügen
                        Object.entries(groups).forEach(([groupNum, texts]) => {
                            const key = groupNum > 1 ? `${label}_Gruppe${groupNum}` : label;
                            const value = texts.join(' ');
                            csv += `"${fileName}","${key}","${value}"\n`;
                        });
                    });
                });
                
                // PDF-Name ohne Erweiterung
                const pdfName = currentPdfFile ? currentPdfFile.replace('.pdf', '') : projectData.name || 'export';
                
                const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${pdfName}.csv`;
                a.click();
                URL.revokeObjectURL(url);
                updateStatus('Als CSV exportiert');
            } catch (err) {
                console.error('Fehler beim CSV-Export:', err);
                updateStatus('Fehler: CSV konnte nicht exportiert werden');
            }
        }

        function updateStatus(message) {
            elements.statusText.textContent = `Status: ${message}`;
        }
    </script>
</body>
</html>
