<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF-Beschriftungssystem</title>
    <!-- Lokale PDF.js Bibliothek -->
    <script src="lib/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        .sidebar {
            width: 300px;
            padding: 20px;
            background: #f8f9fa;
            border-right: 1px solid #ddd;
        }

        .workspace {
            flex: 1;
            padding: 20px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .input-group input[type="text"] {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .input-group input[type="color"] {
            width: 40px;
            height: 36px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .label-list,
        .pdf-list {
            margin-top: 10px;
        }

        .label-item,
        .pdf-item {
            padding: 10px;
            border: 1px solid #ddd;
            margin-bottom: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .label-item.active,
        .pdf-item.active {
            background: #e6f0ff;
        }

        .label-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #ddd;
        }

        #pdfDisplay {
            border: 2px dashed #ddd;
            padding: 20px;
            min-height: 400px;
            margin-top: 20px;
        }

        .text-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.2;
            z-index: 10;
        }

        .text-layer>span {
            color: transparent;
            position: absolute;
            cursor: pointer;
            border-radius: 3px;
        }

        .text-layer>span:hover {
            background: rgba(102, 126, 234, 0.3);
            opacity: 1;
        }

        .annotation-highlight {
            position: absolute;
            background: rgba(102, 126, 234, 0.3);
            border: 2px solid;
            pointer-events: none;
            z-index: 5;
        }

        .group-badge {
            position: absolute;
            background: white;
            border: 2px solid;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            z-index: 15;
            pointer-events: none;
            top: -5px;
            right: -5px;
        }

        .mode-toggle {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .mode-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            background: white;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        #statusText {
            margin-top: 10px;
            color: #333;
        }

        .context-menu {
            position: fixed;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            padding: 5px 0;
            min-width: 200px;
        }

        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .context-menu-item:hover {
            background: #f0f3ff;
        }

        .context-menu-divider {
            height: 1px;
            background: #ddd;
            margin: 5px 0;
        }

        .group-input-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            z-index: 1001;
            padding: 20px;
            min-width: 300px;
        }

        .group-input-dialog h3 {
            margin-bottom: 15px;
            color: #667eea;
        }

        .group-input-dialog input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .group-input-dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        .section {
            margin-bottom: 20px;
        }

        .section h3 {
            margin-bottom: 10px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>PDF-Beschriftungssystem</h1>
        <div class="main-content">
            <div class="sidebar">
                <div class="section">
                    <h3>Projekt</h3>
                    <button class="btn btn-primary" id="newProjectBtn">Neues Projekt</button>
                    <button class="btn btn-success" id="saveProjectBtn" disabled>Projekt speichern</button>
                    <button class="btn btn-primary" id="loadProjectBtn">Projekt laden</button>
                    <input type="file" id="projectFileInput" accept=".json" style="display: none;">
                </div>
                <div class="section">
                    <h3>Labels</h3>
                    <div class="input-group">
                        <input type="text" id="labelInput" placeholder="Label-Name" disabled>
                        <input type="color" id="colorInput" value="#ff6b6b" disabled>
                        <button class="btn btn-success" id="addLabelBtn" disabled>+</button>
                    </div>
                    <div class="label-list" id="labelList"></div>
                </div>
                <div class="section">
                    <h3>Modus</h3>
                    <div class="mode-toggle">
                        <button class="mode-btn active" id="labelModeBtn">Beschriften</button>
                        <button class="mode-btn" id="eraserModeBtn">Radierer</button>
                    </div>
                </div>
                <div class="section">
                    <h3>PDF-Datei</h3>
                    <input type="file" id="pdfFileInput" accept=".pdf" style="display: none;" disabled>
                    <button class="btn btn-primary" id="uploadPdfBtn" disabled>PDF hochladen</button>
                    <div class="pdf-list" id="pdfList"></div>
                </div>
                <div class="section">
                    <h3>JSON-Annotationen</h3>
                    <input type="file" id="jsonFileInput" accept=".json" style="display: none;" disabled>
                    <button class="btn btn-primary" id="loadJsonBtn" disabled>JSON laden</button>
                </div>
            </div>
            <div class="workspace">
                <div>
                    <h3>PDF-Ansicht</h3>
                    <div id="pdfDisplay">Warten auf PDF...</div>
                </div>
                <div>
                    <h3>Export</h3>
                    <button class="btn btn-success" id="exportJsonBtn" disabled>JSON herunterladen</button>
                    <button class="btn btn-success" id="exportCsvBtn" disabled>CSV herunterladen</button>
                </div>
            </div>
        </div>
        <div id="statusText">Status: Bereit</div>
    </div>

    <script>
        if (typeof pdfjsLib === 'undefined') {
            console.error('PDF.js Bibliothek konnte nicht geladen werden');
            document.getElementById('statusText').textContent = 'Fehler: PDF.js nicht geladen';
            alert('PDF.js Bibliothek konnte nicht geladen werden. Bitte prüfen Sie lib/pdf.min.js');
        } else {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'lib/pdf.worker.min.js';
        }

        let projectData = {
            name: '',
            date: '',
            classes: {},
            files: {},
            activeLabel: null,
            isEraser: false,
            classGroups: {}
        };
        let currentPdfFile = null;
        let currentPdfDoc = null;
        let currentPage = 1;
        let textSpanMap = new Map();

        const elements = {
            newProjectBtn: document.getElementById('newProjectBtn'),
            saveProjectBtn: document.getElementById('saveProjectBtn'),
            loadProjectBtn: document.getElementById('loadProjectBtn'),
            projectFileInput: document.getElementById('projectFileInput'),
            labelInput: document.getElementById('labelInput'),
            colorInput: document.getElementById('colorInput'),
            addLabelBtn: document.getElementById('addLabelBtn'),
            labelList: document.getElementById('labelList'),
            uploadPdfBtn: document.getElementById('uploadPdfBtn'),
            pdfFileInput: document.getElementById('pdfFileInput'),
            pdfList: document.getElementById('pdfList'),
            pdfDisplay: document.getElementById('pdfDisplay'),
            labelModeBtn: document.getElementById('labelModeBtn'),
            eraserModeBtn: document.getElementById('eraserModeBtn'),
            exportJsonBtn: document.getElementById('exportJsonBtn'),
            exportCsvBtn: document.getElementById('exportCsvBtn'),
            statusText: document.getElementById('statusText'),
            loadJsonBtn: document.getElementById('loadJsonBtn'),
            jsonFileInput: document.getElementById('jsonFileInput')
        };

        elements.newProjectBtn.addEventListener('click', createNewProject);
        elements.saveProjectBtn.addEventListener('click', saveProject);
        elements.loadProjectBtn.addEventListener('click', () => elements.projectFileInput.click());
        elements.addLabelBtn.addEventListener('click', addLabel);
        elements.uploadPdfBtn.addEventListener('click', () => elements.pdfFileInput.click());
        elements.loadJsonBtn.addEventListener('click', () => elements.jsonFileInput.click());

        elements.labelModeBtn.addEventListener('click', () => {
            projectData.isEraser = false;
            elements.labelModeBtn.classList.add('active');
            elements.eraserModeBtn.classList.remove('active');
            updateStatus(`Aktiver Modus: Beschriftung (${projectData.activeLabel || 'Nicht ausgewählt'})`);
        });

        elements.eraserModeBtn.addEventListener('click', () => {
            projectData.isEraser = true;
            projectData.activeLabel = null;
            elements.eraserModeBtn.classList.add('active');
            elements.labelModeBtn.classList.remove('active');
            updateStatus('Aktiver Modus: Radierer');
        });

        elements.exportJsonBtn.addEventListener('click', exportJson);
        elements.exportCsvBtn.addEventListener('click', exportCsv);
        elements.projectFileInput.addEventListener('change', loadProject);
        elements.pdfFileInput.addEventListener('change', uploadPdf);
        elements.jsonFileInput.addEventListener('change', loadJsonAnnotations);

        document.addEventListener('click', () => {
            document.querySelectorAll('.context-menu').forEach(m => m.remove());
        });

        function createNewProject() {
            try {
                const projectName = prompt('Bitte geben Sie den Projektnamen ein:');
                if (projectName) {
                    projectData = {
                        name: projectName,
                        date: new Date().toLocaleDateString('de-DE'),
                        classes: {},
                        files: {},
                        activeLabel: null,
                        isEraser: false,
                        classGroups: {}
                    };
                    currentPdfFile = null;
                    currentPdfDoc = null;
                    textSpanMap.clear();

                    elements.saveProjectBtn.disabled = false;
                    elements.labelInput.disabled = false;
                    elements.colorInput.disabled = false;
                    elements.addLabelBtn.disabled = false;
                    elements.uploadPdfBtn.disabled = true;
                    elements.pdfFileInput.disabled = true;
                    elements.exportJsonBtn.disabled = true;
                    elements.exportCsvBtn.disabled = true;
                    elements.loadJsonBtn.disabled = true;
                    elements.jsonFileInput.disabled = true;

                    elements.pdfDisplay.innerHTML = 'Warten auf PDF...';
                    elements.pdfList.innerHTML = '';
                    elements.labelList.innerHTML = '';
                    updateStatus(`Neues Projekt "${projectName}" erstellt`);
                }
            } catch (err) {
                console.error('Fehler beim Erstellen:', err);
                updateStatus('Fehler: Projekt nicht erstellt');
            }
        }

        function saveProject() {
            try {
                const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${projectData.name || 'projekt'}_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                updateStatus('Projekt gespeichert');
            } catch (err) {
                console.error('Fehler:', err);
                updateStatus('Fehler: Speichern fehlgeschlagen');
            }
        }

        function loadProject(e) {
            try {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const loadedData = JSON.parse(event.target.result);
                        if (!loadedData.name || !loadedData.classes) {
                            throw new Error('Ungültiges Format');
                        }

                        projectData = {
                            name: loadedData.name,
                            date: loadedData.date || new Date().toLocaleDateString('de-DE'),
                            classes: loadedData.classes || {},
                            files: loadedData.files || {},
                            activeLabel: null,
                            isEraser: false,
                            classGroups: loadedData.classGroups || {}
                        };

                        currentPdfFile = null;
                        currentPdfDoc = null;
                        textSpanMap.clear();

                        elements.saveProjectBtn.disabled = false;
                        elements.labelInput.disabled = false;
                        elements.colorInput.disabled = false;
                        elements.addLabelBtn.disabled = false;
                        elements.uploadPdfBtn.disabled = false;
                        elements.pdfFileInput.disabled = false;
                        elements.exportJsonBtn.disabled = false;
                        elements.exportCsvBtn.disabled = false;
                        elements.loadJsonBtn.disabled = false;
                        elements.jsonFileInput.disabled = false;

                        elements.pdfDisplay.innerHTML = 'Warten auf PDF...';
                        renderLabels();
                        renderPdfList();
                        updateStatus(`Projekt "${projectData.name}" geladen`);
                    } catch (err) {
                        console.error('Fehler:', err);
                        updateStatus('Fehler: Projekt nicht geladen');
                        alert('Projektdatei konnte nicht geladen werden: ' + err.message);
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            } catch (err) {
                console.error('Fehler:', err);
                updateStatus('Fehler: Laden fehlgeschlagen');
            }
        }

        function addLabel() {
            try {
                const labelName = elements.labelInput.value.trim();
                const labelColor = elements.colorInput.value;

                if (labelName && !projectData.classes[labelName]) {
                    projectData.classes[labelName] = labelColor;
                    projectData.classGroups[labelName] = null;
                    renderLabels();
                    elements.labelInput.value = '';
                    elements.uploadPdfBtn.disabled = false;
                    elements.pdfFileInput.disabled = false;
                    elements.exportJsonBtn.disabled = false;
                    elements.exportCsvBtn.disabled = false;
                    elements.loadJsonBtn.disabled = false;
                    elements.jsonFileInput.disabled = false;
                    updateStatus(`Label "${labelName}" hinzugefügt`);
                } else {
                    updateStatus('Fehler: Label leer oder existiert');
                }
            } catch (err) {
                console.error('Fehler:', err);
                updateStatus('Fehler: Label nicht hinzugefügt');
            }
        }

        function renderLabels() {
            elements.labelList.innerHTML = '';
            Object.entries(projectData.classes).forEach(([name, color]) => {
                const currentGroup = projectData.classGroups[name] ?? '';
                const item = document.createElement('div');
                item.className = `label-item ${projectData.activeLabel === name ? 'active' : ''}`;
                item.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; flex: 1;">
                        <div class="label-color" style="background: ${color};"></div>
                        <span style="flex: 1;">${name}</span>
                        <input type="number" min="1" placeholder="Gruppe" value="${currentGroup}"
                               style="width: 60px; padding: 4px; font-size: 12px; border: 1px solid #ccc; border-radius: 4px;"
                               data-label="${name}" class="label-group-input">
                    </div>
                    <button class="btn btn-danger" style="padding: 5px 10px;">×</button>
                `;

                const groupInput = item.querySelector('.label-group-input');
                groupInput.addEventListener('change', (e) => {
                    const val = parseInt(e.target.value) || null;
                    projectData.classGroups[name] = val;
                    updateStatus(`Gruppe für "${name}": ${val ?? 'keine'}`);
                });

                const deleteBtn = item.querySelector('.btn-danger');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteLabel(name);
                });

                item.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('btn') && !e.target.classList.contains('label-group-input')) {
                        projectData.activeLabel = name;
                        projectData.isEraser = false;
                        elements.labelModeBtn.classList.add('active');
                        elements.eraserModeBtn.classList.remove('active');
                        renderLabels();
                        const grp = projectData.classGroups[name];
                        updateStatus(`Aktives Label: ${name} (Gruppe: ${grp ?? 'keine'})`);
                    }
                });
                elements.labelList.appendChild(item);
            });
        }

        function deleteLabel(name) {
            try {
                if (confirm(`Möchten Sie das Label "${name}" wirklich löschen?`)) {
                    delete projectData.classes[name];
                    if (projectData.activeLabel === name) {
                        projectData.activeLabel = null;
                    }
                    delete projectData.classGroups[name];
                    renderLabels();
                    updateStatus(`Label "${name}" gelöscht`);
                }
            } catch (err) {
                console.error('Fehler:', err);
                updateStatus('Fehler: Löschen fehlgeschlagen');
            }
        }

        async function uploadPdf(e) {
            if (typeof pdfjsLib === 'undefined') {
                updateStatus('Fehler: PDF.js nicht geladen');
                return;
            }
            try {
                const file = e.target.files[0];
                if (!file) return;

                const fileName = file.name;
                projectData.files[fileName] = {
                    annotations: {},
                    pdfData: null,
                    numPages: 0
                };

                Object.keys(projectData.classes).forEach(label => {
                    projectData.files[fileName].annotations[label] = [];
                });

                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        projectData.files[fileName].pdfData = event.target.result;
                        const loadingTask = pdfjsLib.getDocument({ data: event.target.result });
                        const pdf = await loadingTask.promise;
                        projectData.files[fileName].numPages = pdf.numPages;
                        renderPdfList();
                        updateStatus(`PDF "${fileName}" hochgeladen`);
                        await loadPdf(fileName);
                    } catch (err) {
                        console.error('Fehler:', err);
                        updateStatus(`Fehler: "${fileName}" nicht geladen`);
                    }
                };
                reader.readAsArrayBuffer(file);
                e.target.value = '';
            } catch (err) {
                console.error('Fehler:', err);
                updateStatus('Fehler: PDF nicht hochgeladen');
            }
        }

        function renderPdfList() {
            elements.pdfList.innerHTML = '';
            Object.keys(projectData.files).forEach(fileName => {
                const item = document.createElement('div');
                item.className = `pdf-item ${currentPdfFile === fileName ? 'active' : ''}`;
                item.innerHTML = `
                    <span style="flex: 1; cursor: pointer;">${fileName}</span>
                    <button class="btn btn-danger" style="padding: 5px 10px;">×</button>
                `;
                item.querySelector('span').addEventListener('click', () => loadPdf(fileName));
                item.querySelector('.btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    deletePdf(fileName);
                });
                elements.pdfList.appendChild(item);
            });
        }

        function deletePdf(fileName) {
            try {
                if (confirm(`Möchten Sie "${fileName}" wirklich löschen?`)) {
                    delete projectData.files[fileName];
                    if (currentPdfFile === fileName) {
                        currentPdfFile = null;
                        currentPdfDoc = null;
                        textSpanMap.clear();
                        elements.pdfDisplay.innerHTML = 'Warten auf PDF...';
                    }
                    renderPdfList();
                    updateStatus('PDF gelöscht');
                }
            } catch (err) {
                console.error('Fehler:', err);
                updateStatus('Fehler: Löschen fehlgeschlagen');
            }
        }

        async function loadPdf(fileName) {
            if (typeof pdfjsLib === 'undefined') {
                updateStatus('Fehler: PDF.js nicht geladen');
                return;
            }
            if (!projectData.files[fileName] || !projectData.files[fileName].pdfData) {
                updateStatus(`Fehler: "${fileName}" nicht gefunden`);
                return;
            }
            try {
                if (currentPdfDoc) {
                    await currentPdfDoc.destroy();
                    currentPdfDoc = null;
                }
                currentPdfFile = fileName;
                currentPage = 1;
                textSpanMap.clear();
                renderPdfList();
                updateStatus(`Lade PDF "${fileName}"...`);
                await renderPage(1);
                updateStatus(`PDF "${fileName}" geladen`);
            } catch (err) {
                console.error('Fehler:', err);
                updateStatus(`Fehler: "${fileName}" nicht geladen`);
            }
        }

        async function renderPage(pageNum) {
            if (!currentPdfFile) return;

            try {
                if (!currentPdfDoc) {
                    const loadingTask = pdfjsLib.getDocument({ data: projectData.files[currentPdfFile].pdfData });
                    currentPdfDoc = await loadingTask.promise;
                }

                currentPage = pageNum;
                const page = await currentPdfDoc.getPage(pageNum);
                const scale = 1.5;
                const viewport = page.getViewport({ scale });

                elements.pdfDisplay.innerHTML = '';

                const controls = document.createElement('div');
                controls.style.cssText = 'display: flex; gap: 10px; margin-bottom: 15px; align-items: center; justify-content: center;';
                controls.innerHTML = `
                    <button class="btn btn-primary" id="prevPageBtn" ${pageNum <= 1 ? 'disabled' : ''}>Zurück</button>
                    <span style="font-weight: bold; min-width: 120px; text-align: center;">Seite ${pageNum} / ${currentPdfDoc.numPages}</span>
                    <button class="btn btn-primary" id="nextPageBtn" ${pageNum >= currentPdfDoc.numPages ? 'disabled' : ''}>Weiter</button>
                `;
                elements.pdfDisplay.appendChild(controls);

                const container = document.createElement('div');
                container.style.position = 'relative';
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const context = canvas.getContext('2d');
                await page.render({ canvasContext: context, viewport }).promise;
                container.appendChild(canvas);

                const textLayer = document.createElement('div');
                textLayer.className = 'text-layer';
                textLayer.style.width = viewport.width + 'px';
                textLayer.style.height = viewport.height + 'px';
                container.appendChild(textLayer);
                elements.pdfDisplay.appendChild(container);

                const textContent = await page.getTextContent();
                await pdfjsLib.renderTextLayer({
                    textContent,
                    container: textLayer,
                    viewport,
                    textDivs: []
                }).promise;

                setupTextInteractivity(textLayer, pageNum);
                restoreAnnotations(container, pageNum);

                document.getElementById('prevPageBtn')?.addEventListener('click', () => {
                    if (currentPage > 1) renderPage(currentPage - 1);
                });

                document.getElementById('nextPageBtn')?.addEventListener('click', () => {
                    if (currentPage < currentPdfDoc.numPages) renderPage(currentPage + 1);
                });

                updateStatus(`Seite ${pageNum}/${currentPdfDoc.numPages} angezeigt`);
            } catch (err) {
                console.error('Fehler:', err);
                updateStatus('Fehler: Seite nicht angezeigt');
            }
        }

        function setupTextInteractivity(textLayer, pageNum) {
            const spans = textLayer.querySelectorAll('span');
            spans.forEach((span, index) => {
                const text = span.textContent.trim();
                if (!text) return;

                const spanId = `span_${pageNum}_${index}`;
                span.dataset.id = spanId;
                textSpanMap.set(spanId, { text, page: pageNum });

                span.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (projectData.isEraser) {
                        removeAnnotationById(spanId, pageNum);
                    } else if (projectData.activeLabel) {
                        addAnnotationById(spanId, pageNum);
                    } else {
                        updateStatus('Fehler: Kein Label ausgewählt');
                    }
                    restoreAnnotations(textLayer.parentElement, pageNum);
                });

                span.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const annotation = findAnnotationBySpanId(spanId);
                    if (annotation) {
                        showContextMenu(e.clientX, e.clientY, spanId, pageNum, annotation);
                    }
                });

                span.addEventListener('mouseenter', () => {
                    if (!projectData.isEraser && projectData.activeLabel) {
                        span.style.background = projectData.classes[projectData.activeLabel] + '40';
                    }
                });
                span.addEventListener('mouseleave', () => {
                    span.style.background = '';
                });
            });
        }

        function addAnnotationById(spanId, pageNum, overrideGroup) {
            try {
                Object.keys(projectData.classes).forEach(label => {
                    const annotations = projectData.files[currentPdfFile].annotations[label] || [];
                    projectData.files[currentPdfFile].annotations[label] = annotations.filter(
                        ann => ann.spanId !== spanId
                    );
                });

                const finalGroup = overrideGroup !== undefined
                    ? overrideGroup
                    : projectData.classGroups[projectData.activeLabel];

                if (!projectData.files[currentPdfFile].annotations[projectData.activeLabel]) {
                    projectData.files[currentPdfFile].annotations[projectData.activeLabel] = [];
                }
                projectData.files[currentPdfFile].annotations[projectData.activeLabel].push({
                    spanId: spanId,
                    page: pageNum,
                    group: finalGroup
                });
            } catch (err) {
                console.error('Fehler:', err);
                updateStatus('Fehler: Beschriftung nicht hinzugefügt');
            }
        }

        function removeAnnotationById(spanId, pageNum) {
            try {
                Object.keys(projectData.classes).forEach(label => {
                    const annotations = projectData.files[currentPdfFile].annotations[label] || [];
                    projectData.files[currentPdfFile].annotations[label] = annotations.filter(
                        ann => ann.spanId !== spanId
                    );
                });
            } catch (err) {
                console.error('Fehler:', err);
                updateStatus('Fehler: Beschriftung nicht entfernt');
            }
        }

        function findAnnotationBySpanId(spanId) {
            for (const [label, annotations] of Object.entries(projectData.files[currentPdfFile].annotations)) {
                const found = annotations.find(ann => ann.spanId === spanId);
                if (found) return { ...found, label };
            }
            return null;
        }

        function showContextMenu(x, y, spanId, pageNum, annotation) {
            const existingMenu = document.querySelector('.context-menu');
            if (existingMenu) existingMenu.remove();

            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.innerHTML = `
                <div class="context-menu-item" data-action="change-group">
                    Gruppe ändern (Aktuell: ${annotation.group ?? 'keine'})
                </div>
                <div class="context-menu-divider"></div>
                <div class="context-menu-item" data-action="remove">
                    Beschriftung entfernen
                </div>
            `;

            menu.addEventListener('click', (e) => {
                e.stopPropagation();
                const action = e.target.dataset.action;
                if (action === 'change-group') {
                    showGroupDialog(spanId, pageNum, annotation);
                } else if (action === 'remove') {
                    removeAnnotationById(spanId, pageNum);
                    restoreAnnotations(document.querySelector('#pdfDisplay > div:last-child'), pageNum);
                }
                menu.remove();
            });

            document.body.appendChild(menu);
        }

        function showGroupDialog(spanId, pageNum, annotation) {
            const overlay = document.createElement('div');
            overlay.className = 'overlay';

            const dialog = document.createElement('div');
            dialog.className = 'group-input-dialog';
            dialog.innerHTML = `
                <h3>Gruppennummer zuweisen</h3>
                <input type="text" id="groupInput" value="${annotation.group ?? ''}" placeholder="Leer lassen = keine Gruppe">
                <div class="group-input-dialog-buttons">
                    <button class="btn btn-primary" id="groupOkBtn">OK</button>
                    <button class="btn btn-danger" id="groupCancelBtn">Abbrechen</button>
                </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);

            const input = document.getElementById('groupInput');
            input.focus();
            input.select();

            document.getElementById('groupOkBtn').addEventListener('click', () => {
                const val = input.value.trim();
                const groupNum = val === '' ? null : (parseInt(val) || null);
                changeAnnotationGroup(spanId, pageNum, annotation.label, groupNum);
                overlay.remove();
                dialog.remove();
                restoreAnnotations(document.querySelector('#pdfDisplay > div:last-child'), pageNum);
            });

            document.getElementById('groupCancelBtn').addEventListener('click', () => {
                overlay.remove();
                dialog.remove();
            });

            overlay.addEventListener('click', () => {
                overlay.remove();
                dialog.remove();
            });
        }

        function changeAnnotationGroup(spanId, pageNum, label, newGroup) {
            try {
                const annotations = projectData.files[currentPdfFile].annotations[label];
                const ann = annotations.find(a => a.spanId === spanId);
                if (ann) {
                    ann.group = newGroup;
                    updateStatus(`Gruppe ${newGroup === null ? 'entfernt' : 'auf ' + newGroup + ' geändert'}`);
                }
            } catch (err) {
                console.error('Fehler:', err);
                updateStatus('Fehler: Gruppe nicht geändert');
            }
        }

        function restoreAnnotations(container, pageNum) {
            if (!container) return;

            const existingHighlights = container.querySelectorAll('.annotation-highlight');
            const existingBadges = container.querySelectorAll('.group-badge');
            existingHighlights.forEach(h => h.remove());
            existingBadges.forEach(b => b.remove());

            Object.entries(projectData.classes).forEach(([label, color]) => {
                const annotations = projectData.files[currentPdfFile]?.annotations[label] || [];
                annotations.forEach(ann => {
                    if (ann.page !== pageNum) return;

                    const textLayer = container.querySelector('.text-layer');
                    if (!textLayer) return;

                    const span = textLayer.querySelector(`[data-id="${ann.spanId}"]`);
                    if (!span) return;

                    const spanRect = span.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();

                    // HER ZAMAN highlight ekle
                    const highlight = document.createElement('div');
                    highlight.className = 'annotation-highlight';
                    highlight.style.backgroundColor = color;
                    highlight.style.opacity = '0.3';
                    highlight.style.left = `${spanRect.left - containerRect.left}px`;
                    highlight.style.top = `${spanRect.top - containerRect.top}px`;
                    highlight.style.width = `${spanRect.width}px`;
                    highlight.style.height = `${spanRect.height}px`;
                    highlight.style.borderColor = color;
                    container.appendChild(highlight);

                    // SADECE grup varsa badge ekle
                    if (ann.group !== null && ann.group !== undefined) {
                        const badge = document.createElement('div');
                        badge.className = 'group-badge';
                        badge.textContent = ann.group;
                        badge.style.borderColor = color;
                        badge.style.color = color;
                        badge.style.left = `${spanRect.right - containerRect.left - 10}px`;
                        badge.style.top = `${spanRect.top - containerRect.top - 5}px`;
                        container.appendChild(badge);
                    }
                });
            });
        }

        function loadJsonAnnotations(e) {
            try {
                const file = e.target.files[0];
                if (!file) return;

                if (!currentPdfFile) {
                    alert('Bitte laden Sie zuerst eine PDF-Datei');
                    updateStatus('Fehler: Keine PDF geladen');
                    e.target.value = '';
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const jsonData = JSON.parse(event.target.result);

                        if (!jsonData.files || !jsonData.files[currentPdfFile]) {
                            alert('Die JSON-Datei enthält keine Annotationen für die aktuelle PDF');
                            updateStatus('Fehler: Keine passenden Annotationen');
                            return;
                        }

                        const fileAnnotations = jsonData.files[currentPdfFile];

                        Object.entries(fileAnnotations).forEach(([key, texts]) => {
                            let label = key;
                            let groupNum = null;

                            const groupMatch = key.match(/^(.+)_Grup(\d+)$/);
                            if (groupMatch) {
                                label = groupMatch[1];
                                groupNum = parseInt(groupMatch[2]);
                            }

                            if (!projectData.classes[label]) {
                                alert(`Label "${label}" existiert nicht im Projekt. Bitte fügen Sie es zuerst hinzu.`);
                                return;
                            }

                            texts.forEach(text => {
                                for (const [spanId, spanInfo] of textSpanMap.entries()) {
                                    if (spanInfo.text === text && spanInfo.page === currentPage) {
                                        const existingAnnotations = projectData.files[currentPdfFile].annotations[label] || [];
                                        const alreadyExists = existingAnnotations.some(ann => ann.spanId === spanId);

                                        if (!alreadyExists) {
                                            projectData.activeLabel = label;
                                            addAnnotationById(spanId, currentPage, groupNum);
                                        }
                                        break;
                                    }
                                }
                            });
                        });

                        const container = document.querySelector('#pdfDisplay > div:last-child');
                        if (container) {
                            restoreAnnotations(container, currentPage);
                        }

                        updateStatus('JSON-Annotationen erfolgreich geladen');
                    } catch (err) {
                        console.error('Fehler beim Verarbeiten der JSON:', err);
                        updateStatus('Fehler: JSON-Datei konnte nicht verarbeitet werden');
                        alert('JSON-Datei konnte nicht verarbeitet werden: ' + err.message);
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            } catch (err) {
                console.error('Fehler beim Laden der JSON:', err);
                updateStatus('Fehler: JSON nicht geladen');
            }
        }

        function exportJson() {
            try {
                const exportData = {
                    project_name: projectData.name,
                    date: projectData.date,
                    classes: projectData.classes,
                    files: {}
                };

                Object.entries(projectData.files).forEach(([fileName, data]) => {
                    exportData.files[fileName] = {};
                    Object.entries(projectData.classes).forEach(([label]) => {
                        const annotations = data.annotations[label] || [];

                        const groups = {};
                        annotations.forEach(ann => {
                            const groupNum = (ann.group !== null && ann.group !== undefined) ? ann.group : 'default';
                            if (!groups[groupNum]) groups[groupNum] = [];
                            const spanInfo = textSpanMap.get(ann.spanId);
                            if (spanInfo) groups[groupNum].push(spanInfo.text);
                        });

                        Object.entries(groups).forEach(([groupNum, texts]) => {
                            const key = groupNum === 'default' ? label : `${label}_Grup${groupNum}`;
                            exportData.files[fileName][key] = texts;
                        });
                    });
                });

                const pdfName = currentPdfFile ? currentPdfFile.replace('.pdf', '') : projectData.name || 'export';
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${pdfName}.json`;
                a.click();
                URL.revokeObjectURL(url);
                updateStatus('JSON exportiert');
            } catch (err) {
                console.error('Fehler:', err);
                updateStatus('Fehler: JSON-Export fehlgeschlagen');
            }
        }

        function exportCsv() {
            try {
                let csv = 'PDF-Datei,Label,Wert\n';

                Object.entries(projectData.files).forEach(([fileName, data]) => {
                    Object.entries(projectData.classes).forEach(([label]) => {
                        const annotations = data.annotations[label] || [];

                        const groups = {};
                        annotations.forEach(ann => {
                            const groupNum = (ann.group !== null && ann.group !== undefined) ? ann.group : 'default';
                            if (!groups[groupNum]) groups[groupNum] = [];
                            const spanInfo = textSpanMap.get(ann.spanId);
                            if (spanInfo) groups[groupNum].push(spanInfo.text);
                        });

                        Object.entries(groups).forEach(([groupNum, texts]) => {
                            const key = groupNum === 'default' ? label : `${label}_Grup${groupNum}`;
                            const value = texts.join(' ');
                            csv += `"${fileName}","${key}","${value}"\n`;
                        });
                    });
                });

                const pdfName = currentPdfFile ? currentPdfFile.replace('.pdf', '') : projectData.name || 'export';
                const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${pdfName}.csv`;
                a.click();
                URL.revokeObjectURL(url);
                updateStatus('CSV exportiert');
            } catch (err) {
                console.error('Fehler:', err);
                updateStatus('Fehler: CSV-Export fehlgeschlagen');
            }
        }

        function updateStatus(message) {
            elements.statusText.textContent = `Status: ${message}`;
        }
    </script>
</body>

</html>
